//
//  Message.swift
//  openai-kit
//
//  Created by Mark DiFranco on 2025-02-10.
//

import Foundation

public struct Message: Codable {
    public let id: String
    public let threadId: String
    public let assistantId: String?
    public let runId: String?
    public let status: Status?
    public let incompleteDetails: IncompleteDetails?
    public let role: Role
    public let content: [Content]
    public let metadata: [String : String]
}

public extension Message {
    enum Status: String, Codable {
        case inProgress = "in_progress"
        case incomplete
        case completed
    }

    enum Role: String, Codable {
        case user
        case assistant
    }

    struct IncompleteDetails: Codable {
        public let reason: String
    }

    enum Content: Codable {
        /// Text content.
        case text(String)
        /// A URL to an image.
        case imageURL(URL, ImageDetail)
        /// A file ID for an image.
        case imageFile(String, ImageDetail)
        /// The refusal content generated by the assistant.
        case refusal(String)
        /// A call to a registered function.
        case functionCall(String, String, String)
    }

    enum ImageDetail: String, Codable {
        case low
        case high
        case auto
    }
}

extension Message.Content {
    public var text: String? {
        switch self {
        case .text(let text):
            return text
        default:
            return nil
        }
    }
    public var imageURL: URL? {
        switch self {
        case .imageURL(let url, _):
            return url
        default:
            return nil
        }
    }
    public var imageFileID: String? {
        switch self {
        case .imageFile(let fileID, _):
            return fileID
        default:
            return nil
        }
    }
}

extension Message.Content {

  private enum ContentKeys: String, CodingKey {
      case id
      case type
      case text
      case imageURL
      case imageFile
      case refusal
      case function
  }

  private enum TextContentKeys: String, CodingKey {
      case value
  }

  private enum ImageURLKeys: String, CodingKey {
      case url
      case detail
  }

  private enum ImageFileKeys: String, CodingKey {
      case fileId
      case detail
  }

  private enum FunctionKeys: String, CodingKey {
      case name
      case arguments
  }

    public init(from decoder: any Decoder) throws {
        let container = try decoder.container(keyedBy: ContentKeys.self)
        let type = try container.decode(String.self, forKey: .type)

        switch type {
        case "text":
            let textContainer = try container.nestedContainer(keyedBy: TextContentKeys.self, forKey: .text)
            let text = try textContainer.decode(String.self, forKey: .value)
            self = .text(text)
        case "image_url":
            let imageURLContainer = try container.nestedContainer(keyedBy: ImageURLKeys.self, forKey: .imageURL)

            if let url = try? imageURLContainer.decode(URL.self, forKey: .url) {
                let detail = try imageURLContainer.decodeIfPresent(Message.ImageDetail.self, forKey: .detail) ?? .auto

                self = .imageURL(url, detail)
            } else {
                throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Unknown image URL")
            }
        case "image_file":
            let imageFileContainer = try container.nestedContainer(keyedBy: ImageFileKeys.self, forKey: .imageFile)

            if let fileID = try? imageFileContainer.decode(String.self, forKey: .fileId) {
                let detail = try imageFileContainer.decodeIfPresent(Message.ImageDetail.self, forKey: .detail) ?? .auto

                self = .imageFile(fileID, detail)
            } else {
                throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Unknown image file ID")
            }
        case "refusal":
            let refusal = try container.decode(String.self, forKey: .refusal)
            self = .refusal(refusal)
        case "function":
            let functionContainer = try container.nestedContainer(keyedBy: FunctionKeys.self, forKey: .function)

            let id = try container.decode(String.self, forKey: .id)
            let name = try functionContainer.decode(String.self, forKey: .name)
            let arguments = try functionContainer.decode(String.self, forKey: .arguments)

            self = .functionCall(id, name, arguments)
        default:
            throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Unknown content type: \(type)")
        }
    }

    public func encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: ContentKeys.self)

        switch self {
        case .text(let text):
            var textContentContainer = container.nestedContainer(keyedBy: TextContentKeys.self, forKey: .text)
            try textContentContainer.encode(text, forKey: .value)
        case .imageURL(let url, let detail):
            try container.encode("image_url", forKey: .type)
            var urlContainer = container.nestedContainer(keyedBy: ImageURLKeys.self, forKey: .imageURL)
            try urlContainer.encode(url, forKey: .url)
            try urlContainer.encode(detail, forKey: .detail)
        case .imageFile(let fileID, let detail):
            try container.encode("image_file", forKey: .type)
            var imageFileContainer = container.nestedContainer(keyedBy: ImageFileKeys.self, forKey: .imageFile)
            try imageFileContainer.encode(fileID, forKey: .fileId)
            try imageFileContainer.encode(detail, forKey: .detail)
        case .refusal(let refusal):
            try container.encode("refusal", forKey: .type)
            try container.encode(refusal, forKey: .refusal)
        case .functionCall(let id, let name, let arguments):
            try container.encode(id, forKey: .id)
            try container.encode("function", forKey: .type)
            var functionContainer = container.nestedContainer(keyedBy: FunctionKeys.self, forKey: .function)
            try functionContainer.encode(name, forKey: .name)
            try functionContainer.encode(arguments, forKey: .arguments)
        }
    }
}
